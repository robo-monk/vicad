#include <errno.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <ft2build.h>
#include FT_FREETYPE_H
#include FT_SYNTHESIS_H

#define FIRST_CHAR 32
#define LAST_CHAR 126
#define GLYPH_COUNT (LAST_CHAR - FIRST_CHAR + 1)

#define PACK_ATLAS_W 1024
#define PACK_ATLAS_H 1024
#define PACK_PAD 1

typedef struct {
    uint16_t codepoint;
    uint16_t x;
    uint16_t y;
    uint16_t w;
    uint16_t h;
    int16_t bearing_x;
    int16_t bearing_y;
    int16_t advance;
} BakedGlyph;

static int next_pow2(int value) {
    int out = 1;
    while (out < value) out <<= 1;
    return out;
}

static void fail(const char *message) {
    fprintf(stderr, "font_baker: %s\n", message);
    exit(1);
}

static void fail_errno(const char *message, const char *path) {
    fprintf(stderr, "font_baker: %s (%s): %s\n", message, path, strerror(errno));
    exit(1);
}

int main(int argc, char **argv) {
    if (argc < 3 || argc > 4) {
        fprintf(stderr, "usage: %s <font.ttf> <out.h> [pixel_size]\n", argv[0]);
        return 1;
    }

    const char *font_path = argv[1];
    const char *out_path = argv[2];
    int pixel_size = 48;
    if (argc == 4) {
        pixel_size = atoi(argv[3]);
        if (pixel_size <= 0) fail("pixel_size must be > 0");
    }

    FT_Library library = NULL;
    FT_Face face = NULL;
    if (FT_Init_FreeType(&library) != 0) fail("FT_Init_FreeType failed");
    if (FT_New_Face(library, font_path, 0, &face) != 0) fail("FT_New_Face failed");
    if (FT_Select_Charmap(face, FT_ENCODING_UNICODE) != 0) fail("FT_Select_Charmap failed");
    if (FT_Set_Pixel_Sizes(face, 0, (FT_UInt)pixel_size) != 0) fail("FT_Set_Pixel_Sizes failed");

    BakedGlyph glyphs[GLYPH_COUNT];
    memset(glyphs, 0, sizeof(glyphs));

    uint8_t *atlas = (uint8_t *)calloc((size_t)PACK_ATLAS_W * (size_t)PACK_ATLAS_H, 1);
    if (!atlas) fail("out of memory allocating atlas");

    int pen_x = PACK_PAD;
    int pen_y = PACK_PAD;
    int row_h = 0;
    int used_x = 1;
    int used_y = 1;

    for (int ch = FIRST_CHAR; ch <= LAST_CHAR; ++ch) {
        BakedGlyph *g = &glyphs[ch - FIRST_CHAR];
        g->codepoint = (uint16_t)ch;

        if (FT_Load_Char(face, (FT_ULong)ch, FT_LOAD_RENDER | FT_LOAD_TARGET_NORMAL) != 0) {
            fprintf(stderr, "font_baker: FT_Load_Char failed for U+%04X\n", ch);
            free(atlas);
            FT_Done_Face(face);
            FT_Done_FreeType(library);
            return 1;
        }

        FT_GlyphSlot slot = face->glyph;
        FT_GlyphSlot_Embolden(slot);
        const int w = (int)slot->bitmap.width;
        const int h = (int)slot->bitmap.rows;

        g->w = (uint16_t)w;
        g->h = (uint16_t)h;
        g->bearing_x = (int16_t)slot->bitmap_left;
        g->bearing_y = (int16_t)slot->bitmap_top;
        g->advance = (int16_t)((slot->advance.x + 32) >> 6);

        if (w <= 0 || h <= 0) continue;

        if (pen_x + w + PACK_PAD > PACK_ATLAS_W) {
            pen_x = PACK_PAD;
            pen_y += row_h;
            row_h = 0;
        }

        if (pen_y + h + PACK_PAD > PACK_ATLAS_H) {
            free(atlas);
            FT_Done_Face(face);
            FT_Done_FreeType(library);
            fail("atlas overflow; increase PACK_ATLAS_W/PACK_ATLAS_H");
        }

        g->x = (uint16_t)pen_x;
        g->y = (uint16_t)pen_y;

        const int pitch = slot->bitmap.pitch;
        for (int y = 0; y < h; ++y) {
            const uint8_t *src_row = NULL;
            if (pitch >= 0) {
                src_row = slot->bitmap.buffer + (size_t)y * (size_t)pitch;
            } else {
                src_row = slot->bitmap.buffer + (size_t)(h - 1 - y) * (size_t)(-pitch);
            }
            uint8_t *dst = atlas + (size_t)(pen_y + y) * PACK_ATLAS_W + (size_t)pen_x;
            memcpy(dst, src_row, (size_t)w);
        }

        pen_x += w + PACK_PAD;
        if (h + PACK_PAD > row_h) row_h = h + PACK_PAD;
        if (pen_x > used_x) used_x = pen_x;
        if (pen_y + h > used_y) used_y = pen_y + h;
    }

    const int atlas_w = next_pow2(used_x + PACK_PAD);
    const int atlas_h = next_pow2(used_y + PACK_PAD);
    if (atlas_w > PACK_ATLAS_W || atlas_h > PACK_ATLAS_H) {
        free(atlas);
        FT_Done_Face(face);
        FT_Done_FreeType(library);
        fail("computed atlas size exceeds packing bounds");
    }

    int ascender = (int)(face->size->metrics.ascender >> 6);
    int descender = (int)(-(face->size->metrics.descender >> 6));
    int line_height = (int)(face->size->metrics.height >> 6);
    if (line_height <= 0) line_height = pixel_size;
    if (ascender <= 0) ascender = pixel_size;
    if (descender < 0) descender = 0;

    FILE *out = fopen(out_path, "wb");
    if (!out) fail_errno("failed to open output header", out_path);

    fprintf(out, "/* Generated by tools/font_baker.c. Do not edit. */\n");
    fprintf(out, "#ifndef VICAD_FUNNEL_SANS_BAKED_H_\n");
    fprintf(out, "#define VICAD_FUNNEL_SANS_BAKED_H_\n\n");
    fprintf(out, "#include <stdint.h>\n\n");
    fprintf(out, "typedef struct VicadBakedGlyph {\n");
    fprintf(out, "    uint16_t codepoint;\n");
    fprintf(out, "    uint16_t x;\n");
    fprintf(out, "    uint16_t y;\n");
    fprintf(out, "    uint16_t w;\n");
    fprintf(out, "    uint16_t h;\n");
    fprintf(out, "    int16_t bearing_x;\n");
    fprintf(out, "    int16_t bearing_y;\n");
    fprintf(out, "    int16_t advance;\n");
    fprintf(out, "} VicadBakedGlyph;\n\n");

    fprintf(out, "enum {\n");
    fprintf(out, "    VICAD_BAKED_FIRST_CHAR = %d,\n", FIRST_CHAR);
    fprintf(out, "    VICAD_BAKED_LAST_CHAR = %d,\n", LAST_CHAR);
    fprintf(out, "    VICAD_BAKED_CHAR_COUNT = %d,\n", GLYPH_COUNT);
    fprintf(out, "    VICAD_BAKED_PIXEL_SIZE = %d,\n", pixel_size);
    fprintf(out, "    VICAD_BAKED_ASCENDER = %d,\n", ascender);
    fprintf(out, "    VICAD_BAKED_DESCENDER = %d,\n", descender);
    fprintf(out, "    VICAD_BAKED_LINE_HEIGHT = %d,\n", line_height);
    fprintf(out, "    VICAD_BAKED_ATLAS_WIDTH = %d,\n", atlas_w);
    fprintf(out, "    VICAD_BAKED_ATLAS_HEIGHT = %d,\n", atlas_h);
    fprintf(out, "};\n\n");

    fprintf(out, "static const VicadBakedGlyph vicad_baked_glyphs[VICAD_BAKED_CHAR_COUNT] = {\n");
    for (int i = 0; i < GLYPH_COUNT; ++i) {
        const BakedGlyph *g = &glyphs[i];
        fprintf(out,
                "    {%u, %u, %u, %u, %u, %d, %d, %d},\n",
                (unsigned)g->codepoint,
                (unsigned)g->x,
                (unsigned)g->y,
                (unsigned)g->w,
                (unsigned)g->h,
                (int)g->bearing_x,
                (int)g->bearing_y,
                (int)g->advance);
    }
    fprintf(out, "};\n\n");

    const int total = atlas_w * atlas_h;
    fprintf(out, "static const uint8_t vicad_baked_atlas[VICAD_BAKED_ATLAS_WIDTH * VICAD_BAKED_ATLAS_HEIGHT] = {\n");
    for (int i = 0; i < total; ++i) {
        if ((i % 16) == 0) fprintf(out, "    ");
        fprintf(out, "0x%02X", (unsigned)atlas[i]);
        if (i + 1 != total) fprintf(out, ", ");
        if ((i % 16) == 15 || i + 1 == total) fprintf(out, "\n");
    }
    fprintf(out, "};\n\n");
    fprintf(out, "#endif /* VICAD_FUNNEL_SANS_BAKED_H_ */\n");

    if (fclose(out) != 0) fail_errno("failed to close output header", out_path);

    free(atlas);
    FT_Done_Face(face);
    FT_Done_FreeType(library);
    return 0;
}
